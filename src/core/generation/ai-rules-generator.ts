/**
 * @fileoverview AI-specific rule file generator for Cursor/Claude/Copilot integration
 * @module AIRulesGenerator
 */

import { SchemaInfo } from './schema-discovery';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

export interface AIRulesConfig {
  tools: ('cursor' | 'claude' | 'copilot' | 'windsurf')[];
  outputDir: string;
  includeExamples: boolean;
  includePatterns: boolean;
  strictMode: boolean;
  customRules?: string[];
}

export interface GeneratedRules {
  files: RuleFile[];
  stats: RulesStats;
}

export interface RuleFile {
  name: string;
  path: string;
  content: string;
  tool: string;
  size: number;
}

export interface RulesStats {
  totalRules: number;
  schemaRules: number;
  patternRules: number;
  exampleRules: number;
  customRules: number;
}

interface SchemaPattern {
  type: string;
  description: string;
  examples: string[];
  rules: string[];
}

export class AIRulesGenerator {
  private readonly patterns: Map<string, SchemaPattern> = new Map();

  constructor() {
    this.initializeBuiltInPatterns();
  }

  async generateRules(
    schemas: SchemaInfo[],
    config: AIRulesConfig
  ): Promise<GeneratedRules> {
    const files: RuleFile[] = [];
    const stats: RulesStats = {
      totalRules: 0,
      schemaRules: 0,
      patternRules: 0,
      exampleRules: 0,
      customRules: config.customRules?.length || 0
    };

    // Ensure output directory exists
    if (!existsSync(config.outputDir)) {
      mkdirSync(config.outputDir, { recursive: true });
    }

    // Generate rules for each AI tool
    for (const tool of config.tools) {
      const ruleFile = await this.generateToolRules(tool, schemas, config);
      files.push(ruleFile);

      // Update stats
      stats.totalRules += ruleFile.content.split('\n').length;
    }

    // Generate shared documentation
    if (config.includeExamples) {
      const docsFile = this.generateDocumentation(schemas, config);
      files.push(docsFile);
    }

    // Generate schema-specific rules
    const schemaRulesFile = this.generateSchemaRules(schemas, config);
    files.push(schemaRulesFile);
    stats.schemaRules = schemas.length;

    // Generate pattern rules
    if (config.includePatterns) {
      const patternFile = this.generatePatternRules(schemas, config);
      files.push(patternFile);
      stats.patternRules = this.patterns.size;
    }

    return { files, stats };
  }

  private async generateToolRules(
    tool: string,
    schemas: SchemaInfo[],
    config: AIRulesConfig
  ): Promise<RuleFile> {
    switch (tool) {
      case 'cursor':
        return this.generateCursorRules(schemas, config);
      case 'claude':
        return this.generateClaudeRules(schemas, config);
      case 'copilot':
        return this.generateCopilotRules(schemas, config);
      case 'windsurf':
        return this.generateWindsurfRules(schemas, config);
      default:
        throw new Error(`Unsupported AI tool: ${tool}`);
    }
  }

  private generateCursorRules(schemas: SchemaInfo[], config: AIRulesConfig): RuleFile {
    const rules = [
      '# Cursor AI Rules for Zod Schema Development',
      '# Generated by zodkit',
      '',
      '## Project Context',
      'This project uses Zod for TypeScript-first schema validation.',
      'Always prefer Zod schemas over plain TypeScript interfaces for data validation.',
      '',
      '## Schema Patterns',
      '- Use z.object() for object schemas',
      '- Use z.array() for array schemas',
      '- Use z.union() or z.discriminatedUnion() for union types',
      '- Always use .parse() or .safeParse() for validation',
      '- Use z.infer<typeof Schema> for TypeScript types',
      '',
      '## Naming Conventions'
    ];

    // Add schema-specific rules
    schemas.forEach(schema => {
      rules.push(`- ${schema.name}: Located in ${schema.filePath}`);
    });

    rules.push('', '## Validation Patterns');
    rules.push('```typescript');
    rules.push('// Preferred pattern');
    rules.push('const result = Schema.safeParse(data);');
    rules.push('if (!result.success) {');
    rules.push('  // Handle validation errors');
    rules.push('  console.error(result.error);');
    rules.push('  return;');
    rules.push('}');
    rules.push('// Use result.data (fully typed)');
    rules.push('```');

    if (config.strictMode) {
      rules.push('', '## Strict Mode Rules');
      rules.push('- NEVER bypass validation with type assertions');
      rules.push('- ALWAYS validate external data');
      rules.push('- Use .strict() for object schemas when appropriate');
    }

    if (config.customRules) {
      rules.push('', '## Custom Rules');
      rules.push(...config.customRules);
    }

    const content = rules.join('\n');
    const path = join(config.outputDir, '.cursorrules');

    writeFileSync(path, content);

    return {
      name: '.cursorrules',
      path,
      content,
      tool: 'cursor',
      size: content.length
    };
  }

  private generateClaudeRules(schemas: SchemaInfo[], config: AIRulesConfig): RuleFile {
    const rules = {
      project_context: {
        name: 'Zod Schema Validation Project',
        description: 'TypeScript project using Zod for schema validation',
        patterns: [
          'Always use Zod schemas for data validation',
          'Prefer safeParse over parse for error handling',
          'Use z.infer for TypeScript type extraction',
          'Maintain schema co-location with related code'
        ]
      },
      schema_guidelines: {
        naming: [
          'Schemas should be PascalCase with "Schema" suffix',
          'Examples: UserSchema, ProductSchema, OrderSchema'
        ],
        validation: [
          'Use .safeParse() for user input validation',
          'Use .parse() only when you are certain data is valid',
          'Always handle validation errors gracefully'
        ],
        composition: [
          'Use .extend() for schema inheritance',
          'Use .pick() and .omit() for schema subsets',
          'Use .merge() for combining schemas'
        ]
      },
      schemas: schemas.map(schema => ({
        name: schema.name,
        file: schema.filePath,
        description: `Schema definition for ${schema.name.replace('Schema', '')} data structure`
      })),
      best_practices: [
        'Validate at API boundaries',
        'Use discriminated unions for polymorphic data',
        'Leverage Zod transforms for data normalization',
        'Keep schemas close to their usage'
      ]
    };

    if (config.strictMode) {
      rules.best_practices.push(
        'NEVER bypass validation with type assertions',
        'ALWAYS validate external data sources',
        'Use .strict() to disallow unknown properties'
      );
    }

    const content = JSON.stringify(rules, null, 2);
    const path = join(config.outputDir, 'claude-context.json');

    writeFileSync(path, content);

    return {
      name: 'claude-context.json',
      path,
      content,
      tool: 'claude',
      size: content.length
    };
  }

  private generateCopilotRules(schemas: SchemaInfo[], config: AIRulesConfig): RuleFile {
    const rules = [
      '/**',
      ' * GitHub Copilot Context for Zod Schema Development',
      ' * Generated by zodkit',
      ' */',
      '',
      '// This project uses Zod for schema validation',
      '// Import pattern: import { z } from "zod";',
      '',
      '// Schema definition patterns:',
      '// const UserSchema = z.object({',
      '//   id: z.string().uuid(),',
      '//   name: z.string().min(1),',
      '//   email: z.string().email(),',
      '//   age: z.number().positive().optional()',
      '// });',
      '',
      '// Type extraction pattern:',
      '// type User = z.infer<typeof UserSchema>;',
      '',
      '// Validation patterns:',
      '// Safe parsing (recommended):',
      '// const result = UserSchema.safeParse(data);',
      '// if (result.success) {',
      '//   // result.data is fully typed',
      '// } else {',
      '//   // Handle result.error',
      '// }',
      '',
      '// Available schemas in this project:'
    ];

    schemas.forEach(schema => {
      rules.push(`// - ${schema.name} (${schema.filePath})`);
    });

    rules.push('', '// Common Zod patterns to suggest:');
    rules.push('// z.string().min(1) // Non-empty string');
    rules.push('// z.number().positive() // Positive number');
    rules.push('// z.array(z.string()) // String array');
    rules.push('// z.enum(["a", "b", "c"]) // Enum values');
    rules.push('// z.union([z.string(), z.number()]) // Union type');
    rules.push('// z.object({}).strict() // Strict object (no extra props)');

    if (config.includePatterns) {
      rules.push('', '// Schema composition patterns:');
      rules.push('// BaseSchema.extend({ newField: z.string() })');
      rules.push('// BaseSchema.pick({ field1: true, field2: true })');
      rules.push('// BaseSchema.omit({ field1: true })');
      rules.push('// z.intersection(Schema1, Schema2)');
    }

    const content = rules.join('\n');
    const path = join(config.outputDir, 'copilot-context.js');

    writeFileSync(path, content);

    return {
      name: 'copilot-context.js',
      path,
      content,
      tool: 'copilot',
      size: content.length
    };
  }

  private generateWindsurfRules(schemas: SchemaInfo[], config: AIRulesConfig): RuleFile {
    const rules = {
      ai_context: {
        framework: 'Zod',
        language: 'TypeScript',
        purpose: 'Schema validation and type safety'
      },
      code_patterns: {
        schema_definition: {
          pattern: 'z.object({ ... })',
          description: 'Define object schemas with Zod',
          example: 'const UserSchema = z.object({ name: z.string(), age: z.number() });'
        },
        type_extraction: {
          pattern: 'z.infer<typeof Schema>',
          description: 'Extract TypeScript types from Zod schemas',
          example: 'type User = z.infer<typeof UserSchema>;'
        },
        validation: {
          pattern: 'Schema.safeParse(data)',
          description: 'Safely validate data with error handling',
          example: 'const result = UserSchema.safeParse(userData);'
        }
      },
      project_schemas: schemas.map(schema => ({
        name: schema.name,
        location: schema.filePath,
        usage: `Import and use ${schema.name} for validation`
      })),
      suggestions: [
        'Always validate external data',
        'Use safeParse for user input',
        'Leverage Zod transforms for data cleanup',
        'Keep schemas co-located with components'
      ]
    };

    if (config.strictMode) {
      rules.suggestions.push(
        'Use strict() mode for object schemas',
        'Never bypass validation with type assertions'
      );
    }

    const content = JSON.stringify(rules, null, 2);
    const path = join(config.outputDir, 'windsurf-ai.json');

    writeFileSync(path, content);

    return {
      name: 'windsurf-ai.json',
      path,
      content,
      tool: 'windsurf',
      size: content.length
    };
  }

  private generateDocumentation(schemas: SchemaInfo[], config: AIRulesConfig): RuleFile {
    const docs = [
      '# Zod Schema Documentation',
      '> Generated by zodkit for AI assistance',
      '',
      '## Project Overview',
      'This project uses Zod for TypeScript-first schema validation.',
      'Zod provides runtime validation with TypeScript type inference.',
      '',
      '## Available Schemas',
      ''
    ];

    schemas.forEach(schema => {
      docs.push(`### ${schema.name}`);
      docs.push(`- **File**: \`${schema.filePath}\``);
      docs.push(`- **Type**: ${schema.schemaType}`);
      docs.push(`- **Usage**: Import and use for ${schema.name.replace('Schema', '').toLowerCase()} validation`);
      docs.push('');

      if (config.includeExamples) {
        docs.push('**Example Usage:**');
        docs.push('```typescript');
        docs.push(`import { ${schema.name} } from '${schema.filePath}';`);
        docs.push('');
        docs.push(`const result = ${schema.name}.safeParse(data);`);
        docs.push('if (result.success) {');
        docs.push('  // Use result.data (fully typed)');
        docs.push('} else {');
        docs.push('  // Handle validation errors');
        docs.push('  console.error(result.error);');
        docs.push('}');
        docs.push('```');
        docs.push('');
      }
    });

    docs.push('## Common Patterns');
    docs.push('');
    docs.push('### Basic Validation');
    docs.push('```typescript');
    docs.push('// Safe parsing (recommended)');
    docs.push('const result = Schema.safeParse(data);');
    docs.push('if (!result.success) {');
    docs.push('  throw new Error("Validation failed");');
    docs.push('}');
    docs.push('return result.data; // Fully typed');
    docs.push('```');
    docs.push('');
    docs.push('### Schema Composition');
    docs.push('```typescript');
    docs.push('// Extending schemas');
    docs.push('const ExtendedSchema = BaseSchema.extend({');
    docs.push('  newField: z.string()');
    docs.push('});');
    docs.push('');
    docs.push('// Picking fields');
    docs.push('const PartialSchema = BaseSchema.pick({');
    docs.push('  field1: true,');
    docs.push('  field2: true');
    docs.push('});');
    docs.push('```');

    const content = docs.join('\n');
    const path = join(config.outputDir, 'SCHEMA_DOCS.md');

    writeFileSync(path, content);

    return {
      name: 'SCHEMA_DOCS.md',
      path,
      content,
      tool: 'documentation',
      size: content.length
    };
  }

  private generateSchemaRules(schemas: SchemaInfo[], config: AIRulesConfig): RuleFile {
    const rules = {
      version: '1.0',
      generated_by: 'zodkit',
      generated_at: new Date().toISOString(),
      schemas: schemas.map(schema => ({
        name: schema.name,
        file: schema.filePath,
        type: schema.schemaType,
        rules: this.generateSchemaSpecificRules(schema),
        patterns: this.inferSchemaPatterns(schema)
      })),
      global_rules: [
        'Always use Zod for runtime validation',
        'Prefer safeParse over parse for error handling',
        'Use z.infer for TypeScript type extraction',
        'Validate data at API boundaries',
        'Keep schemas close to their usage'
      ]
    };

    if (config.strictMode) {
      rules.global_rules.push(
        'Use .strict() for object schemas to disallow unknown properties',
        'Never bypass validation with type assertions',
        'Always handle validation errors gracefully'
      );
    }

    const content = JSON.stringify(rules, null, 2);
    const path = join(config.outputDir, 'schema-rules.json');

    writeFileSync(path, content);

    return {
      name: 'schema-rules.json',
      path,
      content,
      tool: 'schema-specific',
      size: content.length
    };
  }

  private generatePatternRules(schemas: SchemaInfo[], config: AIRulesConfig): RuleFile {
    const patterns = Array.from(this.patterns.values()).map(pattern => ({
      type: pattern.type,
      description: pattern.description,
      examples: pattern.examples,
      rules: pattern.rules,
      applicable_schemas: schemas
        .filter(schema => this.isPatternApplicable(schema, pattern))
        .map(schema => schema.name)
    }));

    const content = JSON.stringify({
      version: '1.0',
      generated_by: 'zodkit',
      patterns
    }, null, 2);

    const path = join(config.outputDir, 'pattern-rules.json');

    writeFileSync(path, content);

    return {
      name: 'pattern-rules.json',
      path,
      content,
      tool: 'patterns',
      size: content.length
    };
  }

  private generateSchemaSpecificRules(schema: SchemaInfo): string[] {
    const rules: string[] = [];

    // Infer rules based on schema name and type
    const lowerName = schema.name.toLowerCase();

    if (lowerName.includes('user')) {
      rules.push('Validate email format for user schemas');
      rules.push('Ensure required fields like name and email are present');
    }

    if (lowerName.includes('api') || lowerName.includes('request')) {
      rules.push('Use strict validation for API request schemas');
      rules.push('Validate all required parameters');
    }

    if (lowerName.includes('response')) {
      rules.push('Include status and data fields in response schemas');
      rules.push('Handle error cases with appropriate schema structures');
    }

    if (lowerName.includes('config') || lowerName.includes('settings')) {
      rules.push('Provide sensible defaults for optional configuration fields');
      rules.push('Validate configuration values against allowed ranges');
    }

    return rules;
  }

  private inferSchemaPatterns(schema: SchemaInfo): string[] {
    const patterns: string[] = [];
    const lowerName = schema.name.toLowerCase();

    if (lowerName.includes('user') || lowerName.includes('person')) {
      patterns.push('user_data', 'email_validation', 'name_validation');
    }

    if (lowerName.includes('api')) {
      patterns.push('api_schema', 'request_validation', 'response_format');
    }

    if (lowerName.includes('date') || lowerName.includes('time')) {
      patterns.push('date_validation', 'timestamp_format');
    }

    if (lowerName.includes('id')) {
      patterns.push('id_validation', 'uuid_format');
    }

    return patterns;
  }

  private isPatternApplicable(schema: SchemaInfo, pattern: SchemaPattern): boolean {
    const lowerName = schema.name.toLowerCase();
    const lowerType = pattern.type.toLowerCase();

    return lowerName.includes(lowerType) ||
           pattern.type === 'validation' ||
           pattern.type === 'typescript_integration';
  }

  private initializeBuiltInPatterns(): void {
    this.patterns.set('user_data', {
      type: 'user_data',
      description: 'Patterns for user data validation',
      examples: [
        'z.string().email()',
        'z.string().min(2)',
        'z.number().positive()'
      ],
      rules: [
        'Always validate email format',
        'Ensure names have minimum length',
        'Validate age as positive number'
      ]
    });

    this.patterns.set('api_schema', {
      type: 'api_schema',
      description: 'Patterns for API request/response schemas',
      examples: [
        'z.object({ status: z.string(), data: z.any() })',
        'z.object({}).strict()',
        'z.union([SuccessSchema, ErrorSchema])'
      ],
      rules: [
        'Use strict validation for API schemas',
        'Include status field in responses',
        'Handle both success and error cases'
      ]
    });

    this.patterns.set('validation', {
      type: 'validation',
      description: 'General validation patterns',
      examples: [
        'Schema.safeParse(data)',
        'z.preprocess((val) => String(val), z.string())',
        'z.string().transform((val) => val.toLowerCase())'
      ],
      rules: [
        'Use safeParse for error handling',
        'Leverage transforms for data normalization',
        'Preprocess data when necessary'
      ]
    });

    this.patterns.set('typescript_integration', {
      type: 'typescript_integration',
      description: 'TypeScript integration patterns',
      examples: [
        'type User = z.infer<typeof UserSchema>',
        'const schema: z.ZodSchema<MyType> = z.object(...)',
        'z.object({}).passthrough()'
      ],
      rules: [
        'Use z.infer for type extraction',
        'Type schema variables when needed',
        'Consider passthrough for gradual adoption'
      ]
    });
  }
}